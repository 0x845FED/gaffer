Box3fPlug vs AtomicBox3fPlug
============================

For inputs you might like the Box3fPlug - to allow individual keyframing/expressioning etc of the different components.

For outputs where the whole box is computed as one you should definitely use the AtomicBox3fPlug, because otherwise you are repeating the same calculation each time you are asked for a single component. Gaffer will only ever ever ever allow one plug to be set in compute(). This will not change. If you really want to have a Box3fPlug output, but your computation is atomic, then consider having a hidden AtomicBox3fPlug for which you perform the computation (whcih will be cached (when we have caching) and then implement the compute for the components of the actual Box3fPlug output to read from this cached plug.

Anatomy of a Gaffer application
===============================

The Gaffer framework is designed to allow the creation of a multitude of different specialised applications. Therefore the main gaffer executable is merely an empty shell, capable of loading and running any such application. Gaffer is launched from the command line specifying the name of an application to run, followed by any command line arguments for the application. The following command runs the "test" application, which exercises the gaffer unit tests :

	gaffer test
	
Command line arguments allow a specific test to be run :

	gaffer test -testCase GafferTest.NodeTest

Specifying a script file rather than an application name is a convenience for opening the script in the "gui" application, so the following two commands are equivalent :

	gaffer myScene.gfr
	gaffer gui -scripts myScene.gfr

A closer look at the gaffer executable reveals that it's just a short bash wrapper, which sets up some environment variables and runs bin/gaffer.py, which then does the actual work of loading and running the requested application. At it's core then, any invocation of gaffer is merely a script running in a standard python interpreter. Applications themselves are also implemented in python, although they most likely will use modules implemented in C++ to perform much of the heavy lifting for the sake of performance. 

Gaffer searches for applications on a set of paths defined by the GAFFER_APP_PATHS environment variables. A quick look inside the gaffer installation reveals that the standard applications are installed as follows :

	apps/browser/browser-1.py
	apps/gui/gui-1.py
	apps/test/test-1.py
	...
	
By creating an equivalent layout in another location, and adding that location to the GAFFER_APP_PATHS environment variable, any number of additional apps can be created and run :

	edit ~/gafferApps/helloWorld/helloWorld-1.py
	export GAFFER_APP_PATHS=~/gafferApps
	gaffer helloWorld

HELLO WORLD APP. SOME MENTION OF THE APPLICATION ROOT AND STARTUP FILES.

Hello World Tutorial
====================

In this tutorial we'll get our first taste of the GafferUI module, and write our first Gaffer based application.

So without further ado, here's some familiar looking code...

import GafferUI

window = GafferUI.Window()
text = GafferUI.TextWidget( "Hello World!" )
window.setWidget( text )
window.setVisible( True )

GafferUI.EventLoop.mainEventLoop().start()

Save this in a file helloWorld.py, and we can run it as follows :

gaffer python helloWorld.py

Here we're using the built in "python" application to run our script in an environment where all the Gaffer modules are available. Shortly we'll turn our simple script into an application of its own, so we can handle command line arguments in a nice straightforward way.

Before we do that though, we can simplify our script a little...

import GafferUI

with GafferUI.Window() as window :
	GafferUI.TextWidget( "Hello World!" )

window.setVisible( True )

GafferUI.EventLoop.mainEventLoop().start()

When we use the "with" syntax above, Gaffer automatically keeps a track of the current parent (the widget following the "with") and automatically parents any new widgets underneath it. This cuts down on typing, and pleasingly results in code where the structure of the ui is represented in the indentation of the code.

Let's make our simple UI ever so slightly more functional...

import GafferUI

with GafferUI.Window( title = "Hello World" ) as window :
	with GafferUI.ListContainer() :
		with GafferUI.ListContainer( orientation = GafferUI.ListContainer.Orientation.Horizontal ) :
			GafferUI.Label( "Greeting" )
			greeting = GafferUI.TextWidget( "Hello" )
		with GafferUI.ListContainer( orientation = GafferUI.ListContainer.Orientation.Horizontal ) :
			GafferUI.Label( "Greetee" )
			greetee = GafferUI.TextWidget( "World" )
			
		button = GafferUI.Button( "Greet" )

def greet( button ) :

	print greeting, greetee	 !!!!!!!!!!!!!!!!!

clickedConnection = button.clickedSignal().connect( greet )
			
window.setVisible( True )

GafferUI.EventLoop.mainEventLoop().start()


Anatomy of the main GUI application
===================================

scripts, nodes, plugs, clipboard, windows

Plugins
=======

As Gaffer is heavily python based, a Gaffer plugin is in fact just a standard Python module.